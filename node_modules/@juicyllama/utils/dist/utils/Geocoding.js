"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Geocoding = void 0;
const bbox_polygon_1 = __importDefault(require("@turf/bbox-polygon"));
const helpers_1 = require("@turf/helpers");
const boolean_point_in_polygon_1 = __importDefault(require("@turf/boolean-point-in-polygon"));
const buffer_1 = __importDefault(require("@turf/buffer"));
const bbox_1 = __importDefault(require("@turf/bbox"));
const distance_1 = __importDefault(require("@turf/distance"));
class Geocoding {
    static areCoordinatesInBoundingBox(coordinates, boundingBox) {
        const _bboxPolygon = (0, bbox_polygon_1.default)([boundingBox.west, boundingBox.south, boundingBox.east, boundingBox.north]);
        const pointToCheck = (0, helpers_1.point)([coordinates.longitude, coordinates.latitude]);
        const isPointInBbox = (0, boolean_point_in_polygon_1.default)(pointToCheck, _bboxPolygon);
        return isPointInBbox;
    }
    static areCoordinatesInPolygon(coordinates, polygonCords) {
        const pointToCheck = (0, helpers_1.point)([coordinates.longitude, coordinates.latitude]);
        const poly = (0, helpers_1.polygon)([polygonCords.map((p) => [p.longitude, p.latitude])]);
        const isPointInBbox = (0, boolean_point_in_polygon_1.default)(pointToCheck, poly);
        return isPointInBbox;
    }
    static areCoordinatesBetweenTwoPoints(coordinates, northeast, southwest, expand_by_meters) {
        if (!(southwest === null || southwest === void 0 ? void 0 : southwest.longitude) || !(southwest === null || southwest === void 0 ? void 0 : southwest.latitude) || !(northeast === null || northeast === void 0 ? void 0 : northeast.longitude) || !(northeast === null || northeast === void 0 ? void 0 : northeast.latitude)) {
            return false;
        }
        if (expand_by_meters) {
            const expandedBoundingBox = Geocoding.expandBoundingBox(northeast, southwest, expand_by_meters);
            northeast = expandedBoundingBox.northeast;
            southwest = expandedBoundingBox.southwest;
        }
        return Geocoding.areCoordinatesInBoundingBox(coordinates, {
            north: northeast.latitude,
            east: northeast.longitude,
            south: southwest.latitude,
            west: southwest.longitude,
        });
    }
    static expandBoundingBox(northeast, southwest, meters) {
        const originalBbox = (0, bbox_polygon_1.default)([
            southwest.longitude,
            southwest.latitude,
            northeast.longitude,
            northeast.latitude,
        ]);
        const bufferedBbox = (0, buffer_1.default)(originalBbox, meters / 1000, { units: 'kilometers' });
        const bufferedBboxExtent = (0, bbox_1.default)(bufferedBbox);
        const newNortheast = {
            latitude: bufferedBboxExtent[3],
            longitude: bufferedBboxExtent[2],
        };
        const newSouthwest = {
            latitude: bufferedBboxExtent[1],
            longitude: bufferedBboxExtent[0],
        };
        return { northeast: newNortheast, southwest: newSouthwest };
    }
    static distanceBetweenTwoPoints(pointA, pointB) {
        const turfPointA = (0, helpers_1.point)([pointA.longitude, pointA.latitude]);
        const turfPointB = (0, helpers_1.point)([pointB.longitude, pointB.latitude]);
        const _distance = (0, distance_1.default)(turfPointA, turfPointB);
        return _distance;
    }
}
exports.Geocoding = Geocoding;
//# sourceMappingURL=Geocoding.js.map